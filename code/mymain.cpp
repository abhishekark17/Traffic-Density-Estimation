#include "mymain.hpp"

using namespace cv;
using namespace std;

int main(int argc, char* argv[])
{	
	//	Initialize I/O	//
	String imagepath="../images/emptyBackground.jpg";
	string videopath="../video/trafficvideo.mp4";
	int method = 0;
	ofstream file;
	ofstream timings;
	timings.open("../analysis/data/time.csv",ios::out|ios::app);
	bool closeFile = false;
	int numOfThreads=5;
	int width=1920;
	int height=1080;
	if (argc==1 || argc == 2) {
		cerr << "Video file and Method should be given as argument" << endl;
		return -1;
	}
	else{
		string videoFileName=argv[1];
		videopath = "../video/"+videoFileName;
		method = stoi(argv[2]);
		if(argc>=4) {
			if(method==4 || method==5) numOfThreads=stoi(argv[3]); 
			else if(method==3) width=stoi(argv[3]);
		}
		if(argc==5) {height=stoi(argv[4]);}
		if (method >5 || method < 0) {
			cerr << "Method argument should be between 0 and 5 (both included)" << endl;
			return -1;
		}
	}

	if (method < 4) closeFile = true;
	// ofstream not needed here for methods 4-5 because they are generated by threads during their respective execution.
	switch (method) {
		case 0: {
			file.open( "../analysis/data/data.csv");
			break;
		}
		case 1: {
			file.open ("../analysis/data/dataM1.csv");
			break;
		}
		case 2: {
			file.open ("../analysis/data/dataM2.csv");
			break;
		}
		case 3: {
			file.open ("../analysis/data/data3/dataM3_"+to_string(width)+"_"+to_string(height)+".csv");
			break;
		}
	}

    VideoCapture cap(videopath);
	if (!cap.isOpened()) {
		cout << "Error: video file is empty" << endl;
		return -1;
	}
	
    //	backGround :: Fixed background for background subtraction for vehicular density	//
    Mat backGround = imread(imagepath);
	

	auto startTime = chrono::high_resolution_clock::now();
	///////////////////////////////////////////////////////////	 WORKSPACE	/////////////////////////////////////////////////////////////////////

	switch (method) {
		case 0: {
			//	This was for Assignment Subtask-2	//
			performSubtask2(backGround, cap, file, 5);
			break;
		}
		case 1: {
			performMethod1 (backGround,cap,file,4,10);
			break;
		}
		case 2: {
			performMethod2 (backGround, cap, file, 4);
			break;
		}
		case 3: {
			performMethod3 (backGround, cap, file, 5,width,height);
			break;
		}
		case 4: {
			performMethod4(videopath,backGround,5,numOfThreads);
			break;
		}
		case 5: {
			// Please warp background here itself for method 5
			backGround = warp(backGround);
			performMethod5(videopath,backGround,5,numOfThreads);
			break;
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto stopTime = chrono::high_resolution_clock::now();
	auto duration = chrono::duration_cast<chrono::seconds> (stopTime - startTime);

	cout << endl << endl ;
	cout << "TOTAL EXECUTION TIME (Method-" + to_string(method) +") :: " << duration.count() << " SECONDS" << endl << endl;
	switch(method){
		case 0: {timings<<"data"<<","<<duration.count()<<endl;break;}
		case 1:	{timings<<"dataM1"<<","<<duration.count()<<endl;break;}
		case 2: {timings<<"dataM2"<<","<<duration.count()<<endl;break;}
		case 3: {timings<<"dataM3_"+to_string(width)+"_"+to_string(height)<<","<<duration.count()<<endl;break;}
		case 4: {timings<<"dataM4N"+to_string(numOfThreads) <<","<<duration.count()<<endl;break;}
		case 5: {timings<<"dataM5N"+to_string(numOfThreads) <<","<<duration.count()<<endl;break;}
	}

	if (closeFile) file.close();
	timings.close();
    return 0;
}